<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="icon" href="logo.jpg">
<title>Inventory Analysis</title>

<!-- Tailwind CDN -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
  body { background: linear-gradient(135deg,#0f172a,#1e293b); color: #e8ecff; font-family: 'Poppins', sans-serif; }
  .card { background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06); border-radius: 14px; padding: 1rem; backdrop-filter: blur(8px); box-shadow: 0 6px 24px rgba(2,6,23,0.6); }
  .muted { color: rgba(232,236,255,0.6); }
  .accent-cyan { color: #06b6d4; }
  .highlight-yellow { color: #facc15; }
  .pill { background: rgba(255,255,255,0.03); padding: 0.25rem 0.6rem; border-radius: 999px; border:1px solid rgba(255,255,255,0.04); }
  table th, table td { border-bottom: 1px solid rgba(255,255,255,0.04); padding: 0.65rem 0.5rem; }
  .low { color: #ff7b7b; font-weight:700; }
  .ok { color: #86efac; font-weight:700; }
  .small-note { font-size:0.85rem; color: rgba(232,236,255,0.65); }
  .tab-btn { padding:0.5rem 1rem; border-radius:0.5rem; cursor:pointer; font-weight:600; }
  .tab-active { background:#06b6d4; color:white; }
  .loading-overlay { position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); color:white; display:flex; align-items:center; justify-content:center; font-size:1.5rem; z-index:10; border-radius:0.75rem; }
  .modal-bg { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); display:flex; justify-content:center; align-items:center; z-index:50; }
  .modal { background:#1e293b; padding:1.5rem; border-radius:12px; max-width:400px; width:90%; color:#e8ecff; }
  .modal input { width:100%; margin-bottom:0.75rem; padding:0.5rem; border-radius:0.5rem; border:1px solid #ccc; background:#07122a; color:#e8ecff; }
  .modal button { margin-right:0.5rem; }

  /* Mobile responsive */
  @media (max-width:768px) {
    .grid-3 { grid-template-columns: 1fr !important; }
    .grid-2 { grid-template-columns: 1fr !important; }
    .card { margin-bottom: 1rem; }
    input, button { width: 100% !important; font-size: 1rem; }
    .flex-col-mobile { flex-direction: column !important; gap: 0.5rem !important; }
    .overflow-x-auto { overflow-x: auto; }
    canvas { max-width: 100% !important; height: auto !important; }
    .mt-mobile { margin-top: 0.5rem !important; }
  }
  .main-row:hover { background: rgba(255,255,255,0.05); transition:0.2s; }
  .expand-arrow { transition: transform 0.2s; cursor:pointer; }
  .detail-row { background: rgba(255,255,255,0.03); }
  .sticky-header th { position: sticky; top:0; background:#1e293b; z-index:5; }
</style>
</head>
<body class="min-h-screen p-4 relative">

<!-- Back Button -->
<div class="fixed back-btn-mobile z-50 md:hidden">
  <a href="dashboard.html" class="flex items-center gap-2 px-3 py-1 bg-red-600 hover:bg-red-700 text-white rounded-lg font-semibold shadow-lg text-sm">
    ⮐ Back
  </a>
</div>

<div class="max-w-7xl mx-auto space-y-6 relative">

  <!-- Tabs -->
  <div class="flex gap-4 mb-4 mt-12 flex-col-mobile">
    <div id="housekeepingTab" class="tab-btn tab-active">Housekeeping</div>
    <div id="electricalTab" class="tab-btn">Electrical</div>
  </div>

  <!-- Threshold + Refresh -->
  <div class="flex flex-col md:flex-row items-start md:items-center justify-between gap-4 mb-4 flex-col-mobile">
    <div class="flex flex-col md:flex-row items-start md:items-center gap-3">
      <label class="small-note mr-2">Low-stock threshold</label>
      <input type="number" value="10" min="0" class="p-2 rounded bg-[#07122a] border border-white/10 w-24 text-white" id="currentThreshold" />
      <button class="ml-0 md:ml-2 mt-2 md:mt-0 px-3 py-2 rounded bg-cyan-500 hover:bg-cyan-600 text-white font-semibold" id="currentRefresh">Refresh</button>
      <button class="ml-0 md:ml-2 mt-2 md:mt-0 px-3 py-2 rounded bg-yellow-400 hover:bg-yellow-300 text-black font-semibold" id="currentExport">Export CSV</button>
    </div>
  </div>

  <!-- Loading overlay -->
  <div id="loadingOverlay" class="loading-overlay hidden">Loading...</div>

  <!-- Tab contents -->
  <div id="housekeepingContent" class="relative"></div>
  <div id="electricalContent" class="hidden relative"></div>

</div>

<!-- Edit Modal -->
<div id="editModal" class="modal-bg hidden">
  <div class="modal">
    <h2 class="text-lg font-semibold accent-cyan mb-2">Edit Item</h2>
    <input type="text" id="editItemName" placeholder="Item Name" disabled />
    <input type="number" id="editTotal" placeholder="Total Quantity" />
    <input type="number" id="editAvailable" placeholder="Available Quantity" />
    <div class="flex justify-end">
      <button id="cancelEdit" class="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded">Cancel</button>
      <button id="saveEdit" class="bg-cyan-500 hover:bg-cyan-600 px-3 py-1 rounded text-white">Save</button>
      <button id="deleteItem" class="bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-white">Delete</button>
    </div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-app.js";
import { getFirestore, collection, getDocs, doc, deleteDoc, updateDoc } from "https://www.gstatic.com/firebasejs/10.4.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyCtdmsd0gWLPqwNpRI2lpiif_FuG-PTHjQ",
  authDomain: "ao-asset.firebaseapp.com",
  projectId: "ao-asset",
  storageBucket: "ao-asset.firebasestorage.app",
  messagingSenderId: "406786910363",
  appId: "1:406786910363:web:1d837738aab6c6b9d73e3e",
  measurementId: "G-4H7RF76176"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const COLLECTIONS = {
  housekeeping: ['housekeepingItemsInventory'],
  electrical: ['electricalItemsInventory']
};

let currentTab = 'housekeeping';
const housekeepingTabBtn = document.getElementById('housekeepingTab');
const electricalTabBtn = document.getElementById('electricalTab');
const housekeepingContent = document.getElementById('housekeepingContent');
const electricalContent = document.getElementById('electricalContent');
const currentThreshold = document.getElementById('currentThreshold');
const currentRefresh = document.getElementById('currentRefresh');
const currentExport = document.getElementById('currentExport');
const loading = document.getElementById('loadingOverlay');
const editModal = document.getElementById('editModal');
const editItemName = document.getElementById('editItemName');
const editTotal = document.getElementById('editTotal');
const editAvailable = document.getElementById('editAvailable');
const cancelEdit = document.getElementById('cancelEdit');
const saveEdit = document.getElementById('saveEdit');
const deleteItemBtn = document.getElementById('deleteItem');

let lastAgg = {housekeeping:null, electrical:null};
let fullRecords = [];

let editTarget = null; // {type, docId, itemName}

// Tab switching
housekeepingTabBtn.addEventListener('click', async () => { currentTab='housekeeping'; switchTabs(); });
electricalTabBtn.addEventListener('click', async () => { currentTab='electrical'; switchTabs(); });

async function switchTabs(){
  housekeepingTabBtn.classList.toggle('tab-active', currentTab==='housekeeping');
  electricalTabBtn.classList.toggle('tab-active', currentTab!=='housekeeping');
  housekeepingContent.classList.toggle('hidden', currentTab!=='housekeeping');
  electricalContent.classList.toggle('hidden', currentTab!=='electrical');
  await refreshTab();
}

// Fetch collection
async function fetchCollection(name){
  try{
    const snap = await getDocs(collection(db,name));
    return snap.docs.map(d=>({id:d.id,data:d.data()}));
  }catch(e){ console.error(e); return []; }
}

function parseTimestamp(val){
  if(!val) return null;
  if(typeof val?.toDate==='function') return val.toDate();
  if(val instanceof Date) return val;
  const d = new Date(val);
  return isNaN(d)?null:d;
}

async function fetchAndAggregate(type){
  const records=[];
  for(const col of COLLECTIONS[type]){
    const docs = await fetchCollection(col);
    for(const docSnap of docs){
      const d = docSnap.data;
      const ts = parseTimestamp(d.timestamp||d.date||d.createdAt) || new Date();
      if(Array.isArray(d.items)){
        for(const it of d.items){
          records.push({
            item: it.item || it.name || it.itemName || it,
            total: Number(it.total || it.totalQty || it.quantity || 0),         // purchased (this month)
            current: Number(it.current ?? it.available ?? it.currentQty ?? 0), // leftover/current from DB
            timestamp: parseTimestamp(it.timestamp) || ts,
            docId: docSnap.id,
            collection: col
          });
        }
      } else if(d.item || d.name){
        records.push({
          item: d.item||d.name,
          total: Number(d.total||d.quantity||0),
          current: Number(d.current||d.available||0),
          timestamp: ts,
          docId: docSnap.id,
          collection: col
        });
      }
    }
  }
  fullRecords = records;
  return records;
}

// Analyze: compute finalAvailable = total + current (per record), aggregate per item
function analyzeRecords(records) {
  const itemsMap = new Map();

  records.forEach(r => {
    const name = r.item || 'Unknown';
    const totalPurchased = Number(r.total || 0);
    const currentValue = Number(r.current || 0);
    const finalAvailable = totalPurchased + currentValue;

    if (!itemsMap.has(name)) {
      itemsMap.set(name, {
        name,
        total: 0,
        available: 0,
        lastUpdated: null,
        docIds: [],
        collection: ''
      });
    }

    const e = itemsMap.get(name);
    e.total += totalPurchased;               // accumulate total purchased
    e.available += finalAvailable;           // accumulate total available
    e.lastUpdated = (!e.lastUpdated || r.timestamp > e.lastUpdated) ? r.timestamp : e.lastUpdated;
    e.docIds.push({ docId: r.docId, collection: r.collection });
  });

  // Return sorted result
    // --- Compute monthly available trend ---
  const monthlyMap = new Map();
  records.forEach(r => {
    const date = new Date(r.timestamp);
    const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
    const availableVal = Number(r.total || 0) + Number(r.current || 0);
    monthlyMap.set(key, (monthlyMap.get(key) || 0) + availableVal);
  });
  const monthly = Array.from(monthlyMap.entries()).sort();

  // Return full result
  return { 
    items: Array.from(itemsMap.values()).sort((a, b) => b.total - a.total),
    monthly
  };

}

// Render UI (Total & Available focused). All charts repurposed to Available.
const charts = {};
function renderUI(type, agg, containerId){
  const container = document.getElementById(containerId);
  container.innerHTML = '';
  const threshold = Number(currentThreshold.value || 10);

  const distinct = agg.items.length;
  const totalQty = agg.items.reduce((s,i)=>s + (Number(i.total)||0), 0);
  const lowItems = agg.items.filter(i => Number(i.available || 0) <= threshold);
  const lowCount = lowItems.length;

  container.innerHTML = `
  <section class="grid grid-cols-3 gap-4 grid-3 mb-4">
    <div class="card text-center"><p class="muted">Distinct Items</p><div class="text-2xl font-bold accent-cyan mt-2">${distinct}</div><p class="small-note mt-1">Total different items tracked</p></div>
    <div class="card text-center"><p class="muted">Total Purchased</p><div class="text-2xl font-bold text-green-400 mt-2">${totalQty}</div><p class="small-note mt-1">Sum of reported totals</p></div>
    <div class="card text-center"><p class="muted">Low-stock Items</p><div class="text-2xl font-bold highlight-yellow mt-2">${lowCount}</div><p class="small-note mt-1">Items at/below threshold</p></div>
  </section>

  <section class="grid grid-cols-2 gap-4 grid-2 mb-4">
    <div class="card"><h2 class="text-lg font-semibold accent-cyan">Availability (Top Items)</h2><canvas id="${containerId}Bar" style="height:320px"></canvas></div>
    <div class="card"><h2 class="text-lg font-semibold highlight-yellow">Available Share</h2><canvas id="${containerId}Pie" style="height:320px"></canvas></div>
  </section>

  <section class="grid grid-cols-3 gap-4 mb-4 grid-3">
    <div class="card col-span-2"><h2 class="text-lg font-semibold accent-cyan">Monthly Available Trend</h2><canvas id="${containerId}Line" style="height:260px"></canvas></div>
    <div class="card"><h2 class="text-lg font-semibold highlight-yellow">Low Stock Alerts</h2><div class="mt-3 space-y-2" id="${containerId}Low"></div></div>
  </section>

  <section class="card">
    <div class="flex justify-between items-center mb-3"><h2 class="text-lg font-semibold accent-cyan">Inventory Summary</h2><p class="small-note">Last updated: ${new Date().toLocaleString()}</p></div>
    <div class="overflow-x-auto"><table class="w-full text-left"><thead class="sticky-header"><tr class="text-white/70"><th>Item</th><th>Total</th><th>Available</th><th>Last Updated</th><th>Actions</th></tr></thead><tbody id="${containerId}Table"></tbody></table></div>
  </section>
  `;

  const tableBody = document.getElementById(containerId + 'Table');
  const lowList = document.getElementById(containerId + 'Low');

  // Low-stock items
  lowList.innerHTML = '';
  lowItems.slice(0,6).forEach(i=>{
    const div = document.createElement('div');
    div.className = 'flex justify-between items-center';
    div.innerHTML = `<div><div class="font-semibold">${i.name}</div><div class="muted small-note">Available: <span class="${Number(i.available)<=threshold?'low':''}">${i.available}</span> / Total: ${i.total}</div></div>
                     <div class="pill">${i.available} available</div>`;
    lowList.appendChild(div);
  });

  // Table rows with Edit/Delete
  tableBody.innerHTML = '';
  agg.items.forEach((i, index) => {
    const tr = document.createElement('tr');
    tr.classList.add('main-row');

    // safe docId & collection
    const lastDoc = (i.docIds && i.docIds.length>0) ? i.docIds[i.docIds.length - 1] : {docId:'', collection:''};
    tr.dataset.item = i.name;
    tr.dataset.docId = lastDoc.docId || '';
    tr.dataset.collection = lastDoc.collection || '';

    tr.innerHTML = `
      <td class="align-top flex items-center justify-between">
        <span>${i.name}</span>
        <span class="cursor-pointer expand-arrow" data-index="${index}">▾</span>
      </td>
      <td>${i.total}</td>
      <td>${i.available || 0}</td>
      <td>${i.lastUpdated?new Date(i.lastUpdated).toLocaleString():'-'}</td>
      <td>
        <button class="bg-cyan-500 hover:bg-cyan-600 px-2 py-1 text-white rounded edit-btn">Edit</button>
      </td>
    `;

    tableBody.appendChild(tr);

    const detailTr = document.createElement('tr');
    detailTr.classList.add('detail-row','hidden');
    detailTr.innerHTML = `<td colspan="5" class="bg-[#0f172a] p-2"><div class="detail-container text-sm text-white/80">Loading history...</div></td>`;
    tableBody.appendChild(detailTr);
  });

  // Expand rows: show history entries (Total & Available for each record)
  tableBody.querySelectorAll('.expand-arrow').forEach(arrow=>{
    arrow.addEventListener('click', ()=> {
      const mainRow = arrow.closest('tr');
      const itemName = mainRow.querySelector('td span').textContent;
      const expanded = mainRow.dataset.expanded === 'true';
      if(expanded){
        let next = mainRow.nextElementSibling;
        while(next && next.classList.contains('history-row')){
          const tmp = next.nextElementSibling;
          next.remove();
          next = tmp;
        }
        mainRow.dataset.expanded = 'false';
        arrow.textContent = '▾';
      } else {
        const histories = fullRecords.filter(r=>r.item===itemName).sort((a,b)=>new Date(b.timestamp)-new Date(a.timestamp));
        histories.forEach(h=>{
          const finalAvailable = Number(h.total || 0) + Number(h.current || 0);
          const tr = document.createElement('tr');
          tr.classList.add('history-row');
          tr.innerHTML = `<td colspan="5" class="px-6 py-1 text-sm bg-[#0f172a]/50">Total Purchased: ${h.total}, Current(from DB): ${h.current}, Available: ${finalAvailable}, Timestamp: ${new Date(h.timestamp).toLocaleString()}</td>`;
          mainRow.after(tr);
        });
        mainRow.dataset.expanded = 'true';
        arrow.textContent = '▴';
      }
    });
  });

  // Edit buttons
  tableBody.querySelectorAll('.edit-btn').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const row = btn.closest('tr');
      const name = row.children[0].querySelector('span').textContent;
      const total = row.children[1].textContent;
      const available = row.children[2].textContent;
      editItemName.value = name;
      editTotal.value = total;
      editAvailable.value = available;
      editModal.classList.remove('hidden');
      editTarget = { type, currentTab, itemName: name, row };
    });
  });

  // Charts (all repurposed to Available)
  const top = agg.items.slice(0,12);
  const labels = top.map(x=>x.name);
  const availableData = top.map(x=>Number(x.available||0));

  // Bar chart - Available
  const barCtx = document.getElementById(containerId + 'Bar').getContext('2d');
  if(charts[containerId + 'Bar']) charts[containerId + 'Bar'].destroy();
  charts[containerId + 'Bar'] = new Chart(barCtx,{
    type:'bar',
    data:{ labels, datasets:[{ label:'Available', data: availableData, backgroundColor: generatePalette(labels.length) }]},
    options:{ responsive:true, plugins:{ legend:{ display:false }, tooltip:{ mode:'index', intersect:false }, title:{ display:false } }, scales:{ x:{ ticks:{ color:'#e8ecff' } }, y:{ beginAtZero:true, ticks:{ color:'#e8ecff' } } } }
  });

  // Pie chart - share of available among items
  const pieCtx = document.getElementById(containerId + 'Pie').getContext('2d');
  if(charts[containerId + 'Pie']) charts[containerId + 'Pie'].destroy();
  charts[containerId + 'Pie'] = new Chart(pieCtx,{
    type:'pie',
    data:{ labels: labels, datasets:[{ data: availableData, backgroundColor: generatePalette(labels.length) }]},
    options:{ responsive:true, plugins:{ legend:{ labels:{ color:'#e8ecff' } } } }
  });

  // Line chart - monthly available trend
  const months = agg.monthly.map(m=>m[0]);
  const monthlyAvailable = agg.monthly.map(m=>m[1]);
  const lineCtx = document.getElementById(containerId + 'Line').getContext('2d');
  if(charts[containerId + 'Line']) charts[containerId + 'Line'].destroy();
  charts[containerId + 'Line'] = new Chart(lineCtx,{
    type:'line',
    data:{ labels: months, datasets:[{ label:'Monthly Available', data: monthlyAvailable, borderColor:'#60a5fa', backgroundColor:'rgba(96,165,250,0.12)', fill:true, tension:0.25 }]},
    options:{ responsive:true, plugins:{ legend:{ labels:{ color:'#e8ecff' } } }, scales:{ x:{ ticks:{ color:'#e8ecff' } }, y:{ ticks:{ color:'#e8ecff' } } } }
  });

  return agg;
}

// palette generator
function generatePalette(n){
  const base=['#06b6d4','#4ade80','#facc15','#f97316','#ef4444','#8b5cf6','#60a5fa','#fb7185','#34d399','#f59e0b'];
  return Array.from({length:n},(_,i)=>base[i%base.length]);
}

// CSV
function exportCSV(items,type){
  const header=['Item','Total','Available','LastUpdated'];
  const rows = items.map(i=>[i.name,i.total,i.available,i.lastUpdated?new Date(i.lastUpdated).toISOString():'']);
  const csv = [header,...rows].map(r=>r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv],{type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `${type}_inventory_${new Date().toISOString().slice(0,10)}.csv`;
  a.click(); URL.revokeObjectURL(url);
}

// Refresh tab
async function refreshTab(){
  loading.classList.remove('hidden');
  currentRefresh.disabled=true; currentRefresh.textContent='Loading...';
  try{
    const records = await fetchAndAggregate(currentTab);
    const agg = analyzeRecords(records);
    lastAgg[currentTab] = renderUI(currentTab,agg,currentTab+'Content');
  }catch(e){ console.error(e); alert('Error fetching data'); }
  finally{
    currentRefresh.disabled=false; currentRefresh.textContent='Refresh';
    loading.classList.add('hidden');
  }
}

// Event listeners
currentRefresh.addEventListener('click',refreshTab);
currentThreshold.addEventListener('change',refreshTab);
currentExport.addEventListener('click',()=>{ if(lastAgg[currentTab]) exportCSV(lastAgg[currentTab].items,currentTab); else alert('No data'); });
cancelEdit.addEventListener('click',()=>{ editModal.classList.add('hidden'); editTarget=null; });

saveEdit.addEventListener('click', async ()=>{
  if(!editTarget) return;
  try{
    // find a relevant record to update (latest for that item)
    const rec = fullRecords.find(r=>r.item===editTarget.itemName);
    if(!rec) return;
    const docRef = doc(db, rec.collection, rec.docId);
    // We update the doc fields 'total' and 'current' where appropriate.
    // Note: depending on your document structure (array of items vs single doc), this update may need to target nested fields.
    await updateDoc(docRef, { total: Number(editTotal.value), available: Number(editAvailable.value), current: Number(editAvailable.value) }).catch(()=>{ /* ignore granular structure issues */ });
    editModal.classList.add('hidden'); editTarget=null;
    await refreshTab();
  }catch(e){ console.error(e); alert('Error saving'); }
});

deleteItemBtn.addEventListener('click', async () => {
  if (!editTarget) return;
  if (!confirm('Are you sure you want to delete this entry?')) return;
  try {
    // Delete only the specific doc (careful: doc path depends on structure)
    const docRef = doc(db, editTarget.row.dataset.collection, editTarget.row.dataset.docId);
    await deleteDoc(docRef);
    // Refresh tab data
    await refreshTab();

    // After refresh, try to expand the same item row to show history
    const tableBody = document.getElementById(editTarget.currentTab + 'Content' + 'Table');
    if(tableBody){
      const rows = tableBody.querySelectorAll('tr.main-row');
      for (const row of rows) {
        if (row.dataset.item === editTarget.itemName) {
          // update docId if possible
          const latestRecord = fullRecords
            .filter(r => r.item === editTarget.itemName)
            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];
          if (latestRecord) {
            row.dataset.docId = latestRecord.docId;
            row.dataset.collection = latestRecord.collection;
          }
          const arrow = row.querySelector('.expand-arrow');
          if (arrow) arrow.click();
          break;
        }
      }
    }

    editModal.classList.add('hidden');
    editTarget = null;

  } catch (e) {
    console.error(e);
    alert('Error deleting');
  }
});

refreshTab();
</script>
</body>
</html>
